// Generated by CoffeeScript 1.12.7
var _, convertArgumentsToArray, convertSetToArray, escape, escapeChars, fnArgsRegex, fnBodyBegRegex, fnBodyEndRegex, indentWith, metaChars, prettify, seenListCheck,
  hasProp = {}.hasOwnProperty;

_ = {
  assign: require('lodash/assign'),
  defaults: require('lodash/defaults'),
  isNil: require('lodash/isNil'),
  startsWith: require('lodash/startsWith')
};

_.typeOf = require('@sa0001/type-of');

fnArgsRegex = /function[\s]?\(([^\)]+)?\)/;

fnBodyBegRegex = /^function[\s]?\(([^\)]+)?\)([\s\t\r\n]+)?\{([\s\t\r\n]+)?/;

fnBodyEndRegex = /([\s\t\r\n]+)?\}$/;

metaChars = {
  '\b': '\\b',
  '\t': '\\t',
  '\n': '\\n',
  '\f': '\\f',
  '\r': '\\r',
  '"': '\\"',
  '\\': '\\\\'
};

escapeChars = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g;

escape = function(string) {
  escapeChars.lastIndex = 0;
  if (escapeChars.test(string)) {
    string = string.replace(escapeChars, function(a) {
      var c;
      c = metaChars[a];
      return (typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4));
    });
  }
  return '"' + string + '"';
};

seenListCheck = function(seenList, v) {
  if (seenList.indexOf(v) >= 0) {
    return true;
  } else {
    seenList.push(v);
    return false;
  }
};

indentWith = '\t';

convertSetToArray = function(set) {
  var arr;
  arr = [];
  set.forEach(function(v) {
    return arr.push(v);
  });
  return arr;
};

convertArgumentsToArray = function(arg) {
  return Array.prototype.slice.call(arg, 0);
};

prettify = function(value, opts) {
  var err, fnArgs, fnBody, fnBodyBeg, fnBodyEnd, fnDef, fnStr, i, indentLast, isComplex, item, iterator, j, k, key, ref, ref1, ref2, regexChars, regexStart, result, results, str, type, v, val;
  if (opts == null) {
    opts = {};
  }
  type = _.typeOf(value);
  switch (type) {
    case 'arguments':
      value = convertArgumentsToArray(value);
      value = prettify(value, opts);
      value = '(function(){return arguments}).apply(null,' + value.replace(/,$/, '') + ')';
      return value;
    case 'boolean':
      return String(value);
    case 'date':
      return 'new Date(' + value.getTime() + ' /*' + value.toISOString() + '*/)';
    case 'error':
      if (_.isNil(value.message) || value.message === '') {
        return 'new ' + value.constructor.name + '()';
      } else {
        return 'new ' + value.constructor.name + '("' + value.message + '")';
      }
      break;
    case 'map':
      indentLast = opts.indent;
      opts.indent += indentWith;
      str = "(function(){\n" + opts.indent + "let v = new Map()";
      iterator = value.keys();
      while ((item = iterator.next()) && !item.done) {
        key = item.value;
        val = value.get(key);
        str += "\n" + opts.indent + "v.set(" + (prettify(key, opts)) + ", " + (prettify(val, opts)) + ")";
      }
      str += "\n" + opts.indent + "return v\n" + indentLast + "}())";
      opts.indent = indentLast;
      return str;
    case 'null':
      return String(value);
    case 'number':
      if (isNaN(value)) {
        return 'NaN';
      }
      if (value === 2e308) {
        return 'Infinity';
      }
      if (value === -2e308) {
        return '-Infinity';
      }
      return String(value);
    case 'promise':
      return 'new Promise()';
    case 'regexp':
      return value.toString().replace(/\/\//g, '\/');
    case 'set':
      value = convertSetToArray(value);
      value = prettify(value, opts);
      value = 'new Set(' + value + ')';
      return value;
    case 'string':
      return escape(value);
    case 'symbol':
      value = value.toString();
      value = value.substring(7, value.length - 1);
      value = escape(value);
      return 'Symbol(' + value + ')';
    case 'undefined':
      return String(value);
    case 'weakmap':
      return "new WeakMap(/*...*/)";
    case 'function':
      if (opts.functions !== true) {
        return "'<<Function>>'";
      }
      if (seenListCheck(opts.seenList, value)) {
        return "'<<Recursive>>'";
      }
      indentLast = opts.indent;
      opts.indent += indentWith;
      fnStr = String(value).replace('function(', 'function (');
      try {
        if (_.startsWith(fnStr, 'function')) {
          fnArgs = fnStr.match(fnArgsRegex)[1] || '';
          fnBodyBeg = fnStr.match(fnBodyBegRegex)[0];
          fnBodyEnd = fnStr.match(fnBodyEndRegex)[0];
          fnBody = fnStr.substring(fnBodyBeg.length, fnStr.length - fnBodyEnd.length);
          if (fnBody.length === 0) {
            fnDef = "function (" + fnArgs + ") {}";
          } else {
            fnBody = fnBody.replace(/\n/g, '\n' + opts.indent);
            fnDef = "function (" + fnArgs + ") {\n" + opts.indent + fnBody + "\n" + indentLast + "}";
          }
        } else {
          fnDef = fnStr;
        }
      } catch (error) {
        err = error;
        console.error(err);
        fnDef = fnStr;
      }
      opts.indent = indentLast;
      return fnDef;
    case 'array':
      if (seenListCheck(opts.seenList, value)) {
        return "'<<Recursive>>'";
      }
      indentLast = opts.indent;
      opts.indent += indentWith;
      isComplex = false;
      results = [];
      for (i = j = 0, ref = value.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
        results[i] = prettify(value[i], opts);
        if ((ref1 = results[i].substring(0, 1)) === '[' || ref1 === '{') {
          isComplex = true;
        }
      }
      if (results.length === 0) {
        v = '[]';
      } else {
        result = results.join(', ');
        if (isComplex || result.length > 80) {
          v = '[\n' + opts.indent + results.join(',\n' + opts.indent) + '\n' + indentLast + ']';
        } else {
          v = '[ ' + result + ' ]';
        }
      }
      opts.indent = indentLast;
      return v;
    default:

      /*
      			[object Object]
      			[object JSON]
      			[object Math]
       */
      if (seenListCheck(opts.seenList, value)) {
        return "'<<Recursive>>'";
      }
      indentLast = opts.indent;
      opts.indent += indentWith;
      isComplex = false;
      results = [];
      regexChars = /['": -.]/;
      regexStart = /^[0-9]/;
      for (k in value) {
        if (!hasProp.call(value, k)) continue;
        v = prettify(value[k], opts);
        if ((ref2 = v.substring(0, 1)) === '[' || ref2 === '{') {
          isComplex = true;
        }
        if (regexChars.test(k) || regexStart.test(k)) {
          k = escape(k);
        }
        results.push(k + ': ' + v);
      }
      if (results.length === 0) {
        v = '{}';
      } else {
        result = results.join(', ');
        if (isComplex || result.length > 80) {
          v = '{\n' + opts.indent + results.join(',\n' + opts.indent) + '\n' + indentLast + '}';
        } else {
          v = '{ ' + result + ' }';
        }
      }
      opts.indent = indentLast;
      return v;
  }
};

module.exports = function(value, opts) {
  if (opts == null) {
    opts = {};
  }
  _.defaults(opts, {
    functions: false,
    indentation: '\t'
  });
  _.assign(opts, {
    indent: '',
    seenList: []
  });
  return prettify(value, opts).replace(/\[\t*\[/g, '[[').replace(/\]\t*\]/g, ']]').replace(/\],\t*\[/g, '],[').replace(/\[\t*\{/g, '[{').replace(/\}\t*\]/g, '}]').replace(/\},\t*\{/g, '},{').replace(/,,/g, ',').replace(/,$,/, '').replace(/\t/g, opts.indentation);
};
